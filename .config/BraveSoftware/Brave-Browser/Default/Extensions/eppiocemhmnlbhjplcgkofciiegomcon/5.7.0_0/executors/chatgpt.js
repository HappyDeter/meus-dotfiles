(()=>{const x=(()=>{const x=sessionStorage.getItem("bis_data");return null!==x?JSON.parse(x):null})(),$=x?.config?`${x.id}_t`:null,v=x?.config?.aiMessagesConfig?.CHATGPT||{},{PARSERS:C=[],CHATBOT_NAME:D=""}=v,V=x=>{try{let v={posdMessageId:"PANELOS_MESSAGE",posdHash:(Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15)).substring(0,22),type:"CHATGPT_DATA",from:$,to:$.substring(0,$.length-2),content:x};window.postMessage(v)}catch(x){}},p=function(x,$){let v={chatbotName:D};for(let C of $)C.PATH?.length?v[C.NAME]=O.byPath(x,C.PATH):C.REDUCE_PARAMS&&(v[C.NAME]=O.byReduce(x,C.REDUCE_PARAMS));return v},K=function(x,$){let v=x.messageText;"object"==typeof v&&v?.length&&(v=v.reduce(((x,$)=>"object"==typeof $?x:`${x} ${$}`),"")),x.messageText=v.trim().slice(0,$),x.messageLength=x.messageText.length},Z=async function(x,$,v){const C=$.body.getReader(),D=new TextDecoder("utf-8");let Z="",O=[],U="";try{for(;;){const{done:x,value:$}=await C.read();if(x)break;Z+=D.decode($,{stream:!0});let V=Z.split("\n");for(let x=0;x<V.length;x++){const $=V[x].trim();if($.startsWith("data:")&&v.RECEIVED_MESSAGE.INVALID_VALUES_TO_PARSE.some((x=>!$.includes(x)))){const x=$.slice(5).trim();try{O.push(JSON.parse(x))}catch(x){}}}U||(U=Z.match(new RegExp(v.REGEXP_SESSION_ID_FROM_STREAM))?.groups?.sessionId),Z=V[V.length-1]}}catch(x){}finally{!function(x,$,v){if(x?.body?.length)try{let C=JSON.parse(x.body),D=p(C,v.RULES_GET_USER_VALUES);if(K(D,v.MESSAGE_LIMIT||1e4),!D||!D.messageText)return;D.sessionId||(D.sessionId=$),D.messageType="user",setTimeout((()=>V(D)),0)}catch(x){}}(x,U,v.SENT_MESSAGE),function(x,$,v){if(x?.length)try{let C=p(x,v.RULES_GET_SYSTEM_VALUES);if(!C||!C.messageText)return;C.sessionId||(C.sessionId=$),C.messageType="system",K(C,v.MESSAGE_LIMIT||3e4),setTimeout((()=>V(C)),0)}catch(x){}}(O,U,v.RECEIVED_MESSAGE)}};ParserProcessors={XMLHttpRequest:function(x){const $=self.fetch;self.fetch=async function(v,C={}){const D="string"==typeof v?v:v.url,V=C.method||"GET";try{const v=await $.apply(this,arguments),p=v.clone();return v.ok&&v.body instanceof ReadableStream&&function(x,$,v){return new RegExp(v.REGEXP_URL_CHECK).test(x)&&$===v.REQUEST_METHOD}(D,V,x)&&setTimeout(Z.bind(this,C,p,x),0),v}catch(x){return $.apply(this,arguments)}}}};const O={byReduce:(x,$)=>{const{KEY:v,CHECK_KEY:C,CHECK_VALUE:D,TYPE:V,RED_FLAG_PATH:p,RED_FLAG_VALUE:K,ALT_PATHS_TO_TEXT:Z,ALT_TYPE:U,INVALID_TEXT_VALUES:G,FINISH_VALUE:w}=$;if(p?.length)for(let $ of x){let x=$;for(let $=0;$<p.length;$++){const v=p[$];if(!x[v]){x=null;break}x=x[v]}if(x===K)return null}return x.reduce(((x,$,p,K)=>{if(!$.hasOwnProperty(v))return x;if($[v]===w)return K.splice(p),x;if(typeof $[v]===V)x+=$[v];else if(typeof $[v]===U&&!Array.isArray($[v]))for(let C of Z){let D=O.byPath($[v],C);if(D===w){K.splice(p);break}D&&!G.includes(D)&&(x+=typeof D===V?D:D?.join(""))}if(Array.isArray($[v]))for(let Z of $[v]){if(Z[v]===w){K.splice(p);break}Z[C]===D&&Z[v]&&typeof Z[v]===V&&(x+=Z[v])}return x}),"")},byPath:(x,$)=>{for(let v=0;v<$.length;v++){const C=$[v];if(!x[C]){x=null;break}x=x[C]}return x}};!function(){for(let x of C)x.USE&&ParserProcessors[x.TYPE](x)}()})();